<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>mysql配置主从同步</title>
      <link href="2022/03/22/mysql/mysql-pei-zhi-zhu-cong-tong-bu/"/>
      <url>2022/03/22/mysql/mysql-pei-zhi-zhu-cong-tong-bu/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-环境准备"><a href="#0x00-环境准备" class="headerlink" title="0x00 环境准备"></a>0x00 环境准备</h2><ul><li>macos 12.1</li><li>docker desktop 3.3.1 ， 科学上网/使用docker国内仓库</li></ul><h2 id="创建-mysql-容器"><a href="#创建-mysql-容器" class="headerlink" title="创建 mysql 容器"></a>创建 mysql 容器</h2><h3 id="文件组织结构如下"><a href="#文件组织结构如下" class="headerlink" title="文件组织结构如下"></a>文件组织结构如下</h3><pre class="line-numbers language-none"><code class="language-none">- mysql&#x2F;    - conf&#x2F;        - my.cnf- musql_slave&#x2F;    - conf&#x2F;        - slave.conf- .env- docker-compose.yml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="各文件内容如下"><a href="#各文件内容如下" class="headerlink" title="各文件内容如下"></a>各文件内容如下</h3><blockquote><p>在这里创建两台机器 一主一丛</p></blockquote><h4 id="1-docker-compose-yml-文件"><a href="#1-docker-compose-yml-文件" class="headerlink" title="1. docker-compose.yml 文件"></a>1. <code>docker-compose.yml</code> 文件</h4><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">version: &quot;3&quot;services:   mysql-master:    image: mysql:8.0    container_name: db_master    ports:      - 3316:3306    volumes:      - $&#123;MYSQL_DIR&#125;&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql      - $&#123;MYSQL_DIR&#125;&#x2F;conf&#x2F;my.cnf:&#x2F;etc&#x2F;mysql&#x2F;conf.d&#x2F;my.cnf    command:      - --default_authentication_plugin&#x3D;mysql_native_password      - --character-set-server&#x3D;utf8mb4      - --collation-server&#x3D;utf8mb4_unicode_ci      - --lower_case_table_names&#x3D;2    restart: always     env_file: .env  mysql-slave:    image: mysql:8.0    container_name: db_slave    ports:      - 3317:3306    volumes:      - $&#123;MYSQL_SLAVE_DIR&#125;&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql      - $&#123;MYSQL_SLAVE_DIR&#125;&#x2F;conf&#x2F;slave.cnf:&#x2F;etc&#x2F;mysql&#x2F;conf.d&#x2F;my.cnf    command:      - --default_authentication_plugin&#x3D;mysql_native_password      - --character-set-server&#x3D;utf8mb4      - --collation-server&#x3D;utf8mb4_unicode_ci      - --lower_case_table_names&#x3D;2    restart: always     env_file: .env<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-env文件"><a href="#2-env文件" class="headerlink" title="2. .env文件"></a>2. <code>.env</code>文件</h4><pre class="line-numbers language-env" data-language="env"><code class="language-env">MYSQL_DIR&#x3D;.&#x2F;mysqlMYSQL_SLAVE_DIR&#x3D;.&#x2F;mysql_slaveMYSQL_ROOT_PASSWORD&#x3D;rootMYSQL_USER&#x3D;testMYSQL_PASSWORD&#x3D;test<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-创建主备两台mysql的配置文件"><a href="#3-创建主备两台mysql的配置文件" class="headerlink" title="3. 创建主备两台mysql的配置文件"></a>3. 创建主备两台mysql的配置文件</h4><h5 id="主库的配置文件-my-cnf"><a href="#主库的配置文件-my-cnf" class="headerlink" title="主库的配置文件 my.cnf"></a>主库的配置文件 <code>my.cnf</code></h5><pre class="line-numbers language-cnf" data-language="cnf"><code class="language-cnf">[mysqld]#主从配置# server-id 唯一的服务辨识号,数值位于 1 到 2^32-1之间.# 此值在master和slave上都需要设置.# 如果 “master-host” 没有被设置,则默认为1, 但是如果忽略此选项,MySQL不会作为master生效.server-id&#x3D;1             #服务器 id # log-bin 打开二进制日志功能.                                                                               # 在复制(replication)配置中,作为MASTER主服务器必须打开此项                                                   # 如果你需要从你最后的备份中做基于时间点的恢复,你也同样需要二进制日志. log-bin&#x3D;mysql-bin       #启用二进制日志并设置文件名称binlog-do-db&#x3D;sync-test  #待同步的数据库binlog-ignore-db&#x3D;mysql  #不同步的数据binlog_format &#x3D; mixed #binlog日志格式，mysql默认采用，如果从服务器slave有别的slave要复制那么该slave也需要这一项 expire_logs_days &#x3D; 7 #超过7天的binlog删除 # 开启gtidgtid_mode&#x3D;onenforce-gtid-consistency&#x3D;true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="备库的-配置文件-slave-cnf"><a href="#备库的-配置文件-slave-cnf" class="headerlink" title="备库的 配置文件 slave.cnf"></a>备库的 配置文件 <code>slave.cnf</code></h5><pre class="line-numbers language-cnf" data-language="cnf"><code class="language-cnf">[mysqld]#主从配置server-id&#x3D;4                 #服务器 id log-bin&#x3D;mysql-bin           #二进制文件存放路径binlog_format &#x3D; mixed #binlog日志格式，mysql默认采用，如果从服务器slave有别的slave要复制那么该slave也需要这一项 # replicate-do-db 需要做复制的数据库,如果复制多个数据库，重复设置这选项即可master上不需要此项，slave上需要  replicate-do-db&#x3D;sync-test        #待同步的数据库replicate-ignore-db&#x3D;mysql   #不同步的数据relay_log&#x3D;edu-mysql-relay-bin  ## relay_log配置中继日志# 开启gtidgtid_mode&#x3D;onenforce-gtid-consistency&#x3D;true# 从库设置只读属性read_only&#x3D;1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h2><p>在 docker-compose.yml 文件同级下使用 <code>docker-compose up -d</code> 命令启动容器</p><h2 id="配置主从同步"><a href="#配置主从同步" class="headerlink" title="配置主从同步"></a>配置主从同步</h2><p>容器创建成功后， 连接到备库上， 执行以下SQL</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">&#x2F;* 因为开启了gtid 因此我们这里无需指明 master_log_file 和 master_log_pos *&#x2F;change master to master_host&#x3D;&#39;db_master&#39; , master_port&#x3D;3306,  master_user&#x3D;&#39;root&#39;, master_password&#x3D;&#39;root&#39;,  master_auto_position &#x3D; 1;start slave;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>执行成功后可通过查看从库状态， 其中 <code>Slave_IO_Running</code> 和 <code>Slave_SQL_Running</code> 均为 Yes 表示主从建立成功。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">show slave status;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此时在主mysql的<code>sync-test</code>库上执行的变更会自动同步到备库</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
            <tag> 主从同步 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言36讲-模块二</title>
      <link href="2021/08/30/go/ji-ke-shi-jian-go-yu-yan-36-jiang/mo-kuai-er/"/>
      <url>2021/08/30/go/ji-ke-shi-jian-go-yu-yan-36-jiang/mo-kuai-er/</url>
      
        <content type="html"><![CDATA[<p>极客时间专栏课《Go语言36讲》 模块二的学习笔记</p><h2 id="07-数组和切片"><a href="#07-数组和切片" class="headerlink" title="07 | 数组和切片"></a>07 | 数组和切片</h2><p>初始化数组的方法：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> a <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token keyword">var</span> a  <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">&#125;</span>a <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token comment">// 在数组的声明中 '...' 等于 初始化的元素数量</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>初始化切片的方法：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">//使用make</span>s <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token comment">//用数组初始化</span><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">&#125;</span>s <span class="token operator">:=</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span>s1 <span class="token operator">:=</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token comment">//初始化,与数组不同的是没有长度</span>t <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">&#123;</span><span class="token string">"g"</span><span class="token punctuation">,</span> <span class="token string">"h"</span><span class="token punctuation">,</span> <span class="token string">"i"</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数组和切片的区别"><a href="#数组和切片的区别" class="headerlink" title="数组和切片的区别"></a>数组和切片的区别</h3><p>数组类型的值（以下简称数组）的长度是固定的，而切片类型的值（以下简称切片）是可变长的。<br><img src="image1.png" alt="image1"></p><h3 id="长度和容量"><a href="#长度和容量" class="headerlink" title="长度和容量"></a>长度和容量</h3><p>计算长度：len() ；计算容量：cap()；</p><ul><li>数组：数组的容量永远等于其长度，都是不可变的</li><li>切片：<ol><li>使用make创建切片：长度和容量就是创建时指定的长度和容量</li><li>基于数组或切片创建新切片：切片的长度是表达式中的区间大小，切片的容量是从起始区间到数组最后元素的长度，因为切片是可以向右拓展的。<h4 id="切片扩容"><a href="#切片扩容" class="headerlink" title="切片扩容"></a>切片扩容</h4>当切片容量无法容纳更多元素时切片会发生扩容</li></ol></li></ul><ol><li>一般情况下会扩容为原来的两倍</li><li>当切片原长度 &gt;= 1024 ，GO将会以原容量的1.25倍作为新容量的基准，新容量基准会被调整（不断地与1.25相乘），直到结果不小于原长度与要追加的元素数量之和（以下简称新长度）。最终，新容量往往会比新长度大一些，当然，相等也是可能的。</li><li>如果我们一次追加的元素过多，以至于使新长度比原容量的 2 倍还要大，那么新容量就会以新长度为基准。注意，与前面那种情况一样，最终的新容量在很多时候都要比新容量基准更大一些。<h4 id="扩容时切片的底层数组的变化"><a href="#扩容时切片的底层数组的变化" class="headerlink" title="扩容时切片的底层数组的变化"></a>扩容时切片的底层数组的变化</h4>扩容的时候 Go 语言会生成新的底层数组，也同时生成了新的切片。<br>在无需扩容时，<code>append</code>函数返回的是指向原底层数组的新切片，而在需要扩容时，<code>append</code>函数返回的是指向新底层数组的新切片<br><code>append</code> 函数总会返回新的切片</li></ol><h4 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖 ..."></a>语法糖 <code>...</code></h4><ul><li><p>用法一：函数指定任意数量的形参</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">test1</span><span class="token punctuation">(</span>args <span class="token operator">...</span><span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token comment">//可以接受任意个string参数</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>用法二：将slice打散作为参数传递</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token function">test1</span><span class="token punctuation">(</span>strss<span class="token operator">...</span><span class="token punctuation">)</span> <span class="token comment">//切片被打散传入</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h2 id="08-container包中的那那些容器"><a href="#08-container包中的那那些容器" class="headerlink" title="08 | container包中的那那些容器"></a>08 | container包中的那那些容器</h2><p>….. 没咋看懂</p><h2 id="09-字典的操作和约束"><a href="#09-字典的操作和约束" class="headerlink" title="09 | 字典的操作和约束"></a>09 | 字典的操作和约束</h2><h3 id="为什么字典键的类型会受到约束？"><a href="#为什么字典键的类型会受到约束？" class="headerlink" title="为什么字典键的类型会受到约束？"></a>为什么字典键的类型会受到约束？</h3><p>Go语言字典键的类型不可以是 <strong>函数类型、字典类型、切片类型</strong>。</p><blockquote><p>Go 语言规范规定，在键类型的值之间必须可以施加操作符 <code>==</code>和 <code>!=</code>。换句话说，键类型的值必须要支持判等操作。由于函数类型、字典类型和切片类型的值并不支持判等操作，所以字典的键类型不能是这些类型。<br>如果键的类型是接口类型的，那么键值的实际类型也不能是上述三种类型，否则在程序运行过程中会引发 panic（即运行时恐慌）。</p></blockquote><p>数组类型作为键？？</p><h3 id="在值为nil的字典上执行读操作会成功吗，那写操作呢？"><a href="#在值为nil的字典上执行读操作会成功吗，那写操作呢？" class="headerlink" title="在值为nil的字典上执行读操作会成功吗，那写操作呢？"></a>在值为nil的字典上执行读操作会成功吗，那写操作呢？</h3><p>除了添加键 - 元素对，我们在一个值为<code>nil</code>的字典上做任何操作都不会引起错误。当我们试图在一个值为<code>nil</code>的字典中添加键 - 元素对的时候，Go 语言的运行时系统就会立即抛出一个 panic。你可以运行一下 demo19.go 文件试试看。<br>​</p><h2 id="10-通道的基本操作"><a href="#10-通道的基本操作" class="headerlink" title="10 | 通道的基本操作"></a>10 | 通道的基本操作</h2><p><strong>通道类型的值本身就是并发安全的，这也是 Go 语言自带的、唯一一个可以满足并发安全性的类型。</strong></p><h4 id="通道的创建"><a href="#通道的创建" class="headerlink" title="通道的创建"></a>通道的创建</h4><p>通道的创建需要用到 <code>make</code> 方法</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token comment">//通道中的值是int类型，传递了第二个参数，标识这是一个带缓冲的通道，容量为 3</span><span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token comment">//通道中的值是string类型，没有传递第二个参数，是一个不带缓冲的通道</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="通道中元素的接收和发送"><a href="#通道中元素的接收和发送" class="headerlink" title="通道中元素的接收和发送"></a>通道中元素的接收和发送</h4><p>元素的接收和发送都要使用 <code>&lt;-</code> 操作符</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">ch1 <span class="token operator">:=</span><span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token comment">//向通道中发送数据</span>ch1 <span class="token operator">&lt;-</span> <span class="token number">2</span>ch1 <span class="token operator">&lt;-</span> <span class="token number">3</span>ch1 <span class="token operator">&lt;-</span> <span class="token number">1</span><span class="token comment">//从通道接收数据</span>elem1 <span class="token operator">:=</span> <span class="token operator">&lt;-</span> ch<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="对通道的发送和接收的基本特性"><a href="#对通道的发送和接收的基本特性" class="headerlink" title="对通道的发送和接收的基本特性"></a>对通道的发送和接收的基本特性</h4><ol><li>对于同一个通道，发送操作之间是互斥的，接收操作之间也是互斥的。</li><li>发送操作和接收操作中对元素值的处理都是不可分割的。</li><li>发送操作在完全完成之前会被阻塞。接收操作也是如此。<h4 id="发送操作和接收操作在什么时候可能被长时间的阻塞？"><a href="#发送操作和接收操作在什么时候可能被长时间的阻塞？" class="headerlink" title="发送操作和接收操作在什么时候可能被长时间的阻塞？"></a><strong>发送操作和接收操作在什么时候可能被长时间的阻塞？</strong></h4></li></ol><p><strong>缓冲通道：</strong>如果通道已满，那么对它的所有发送操作都会被阻塞，直到通道中有元素值被接收走。<br><strong>非缓冲通道：</strong>情况要简单一些。无论是发送操作还是接收操作，一开始执行就会被阻塞，直到配对的操作也开始执行，才会继续传递。<br><strong>特例</strong>：对于值为nil的通道，不论它的具体类型是什么，对它的发送操作和接收操作都会永久地处于阻塞状态。它们所属的 goroutine 中的任何代码，都不再会被执行。</p><h4 id="发送操作和接收操作在什么时候会引发-panic？"><a href="#发送操作和接收操作在什么时候会引发-panic？" class="headerlink" title="发送操作和接收操作在什么时候会引发 panic？"></a><strong>发送操作和接收操作在什么时候会引发 panic？</strong></h4><p>对于一个已初始化，但并未关闭的通道来说，收发操作一定不会引发 panic。但是通道一旦关闭，再对它进行发送操作，就会引发 panic。<br>另外，如果我们试图关闭一个已经关闭了的通道，也会引发 panic。注意，接收操作是可以感知到通道的关闭的，并能够安全退出。</p><h2 id="11-通道的高级玩法"><a href="#11-通道的高级玩法" class="headerlink" title="11 | 通道的高级玩法"></a>11 | 通道的高级玩法</h2><h3 id="单向通道"><a href="#单向通道" class="headerlink" title="单向通道"></a>单向通道</h3><blockquote><p><strong>所谓单向通道就是，只能发不能收，或者只能收不能发的通道。一个通道是双向的，还是单向的是由它的类型字面量体现的。</strong></p></blockquote><p>通道字面量 <code>&lt;-</code> 在关键字 <code>chan</code> 左边：表示这个通道是只能收不能发的单向通道</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> uselessChan <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通道字面量<code>&lt;-</code> 在关键字 <code>chan</code> 右边，表示这个通道只能发不能收</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> uselessChan <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span><span class="token operator">&lt;-</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="单向通道的应用价值"><a href="#单向通道的应用价值" class="headerlink" title="单向通道的应用价值"></a>单向通道的应用价值</h4><p>概括地说，单向通道最主要的用途就是约束其他代码的行为。<br>可以用来在声明函数的时候规范参数</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">SendInt</span><span class="token punctuation">(</span>ch <span class="token keyword">chan</span><span class="token operator">&lt;-</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>ch <span class="token operator">&lt;-</span> rand<span class="token punctuation">.</span><span class="token function">Intn</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">getIntChan</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>num <span class="token operator">:=</span> <span class="token number">5</span>ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> num<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>ch <span class="token operator">&lt;-</span> i<span class="token punctuation">&#125;</span><span class="token function">close</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token keyword">return</span> ch<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="select-语句"><a href="#select-语句" class="headerlink" title="select 语句"></a>select 语句</h4><blockquote><p><code>select</code>语句只能与通道联用</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">select</span> <span class="token punctuation">&#123;</span><span class="token keyword">case</span> <span class="token operator">&lt;-</span>intChannels<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"The first candidate case is selected."</span><span class="token punctuation">)</span><span class="token keyword">case</span> <span class="token operator">&lt;-</span>intChannels<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"The second candidate case is selected."</span><span class="token punctuation">)</span><span class="token keyword">case</span> elem <span class="token operator">:=</span> <span class="token operator">&lt;-</span>intChannels<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token comment">//可以把通道的值赋给变量</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"The third candidate case is selected, the element is %d.\n"</span><span class="token punctuation">,</span> elem<span class="token punctuation">)</span><span class="token keyword">default</span><span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"No candidate case is selected!"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>如果加入了默认分支，那么无论涉及通道操作的表达式是否有阻塞，<code>select</code>语句都不会被阻塞。</li></ul><ol><li>如果没有加入默认分支，那么一旦所有的<code>case</code>表达式都没有满足求值条件，那么 <code>select</code> 语句就会被阻塞。直到至少有一个 <code>case</code> 表达式满足条件为止。<h2 id="12-使用函数的正确姿势"><a href="#12-使用函数的正确姿势" class="headerlink" title="12 | 使用函数的正确姿势"></a>12 | 使用函数的正确姿势</h2><h3 id="函数是一等公民"><a href="#函数是一等公民" class="headerlink" title="函数是一等公民"></a>函数是一等公民</h3>在go语言中，函数是一等的公民，也是一等的 <strong>数据类型</strong><br> 函数类型属于引用类型，零值是 <strong>nil</strong><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> module2<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token string">"testing"</span><span class="token punctuation">)</span><span class="token comment">// 声明了函数类型 Printer</span><span class="token keyword">type</span> Printer <span class="token keyword">func</span><span class="token punctuation">(</span>contents <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span><span class="token comment">// printToStd 函数的签名和Printer是一致的，因此printToStd是Printer的一个实现</span><span class="token keyword">func</span> <span class="token function">printToStd</span><span class="token punctuation">(</span>contents <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>contents<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">Test1</span><span class="token punctuation">(</span>t <span class="token operator">*</span>testing<span class="token punctuation">.</span>T<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">var</span> p Printerp <span class="token operator">=</span> printToStd<span class="token boolean">_</span><span class="token punctuation">,</span><span class="token boolean">_</span> <span class="token operator">=</span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token string">"something"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>函数的签名其实就是函数的参数列表和结果列表的统称，它定义了可用来鉴别不同函数的那些特征，同时也定义了我们与函数交互的方式。</p></blockquote></li></ol><p>只要两个函数的参数列表和结果列表中的元素顺序及其类型是一致的，我们就可以说他们是一样的函数，或者说是实现了同一个函数类型的函数。</p><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>高阶函数可以满足以下两个条件</p><ol><li>接收其他函数作为参数返回</li><li>把其他函数作为结果返回</li></ol><p><strong>只要满足了其中任意一个特点就可以说这个函数是一个高阶函数</strong>​</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> operate <span class="token keyword">func</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span><span class="token keyword">func</span> <span class="token function">calculate</span><span class="token punctuation">(</span>x <span class="token builtin">int</span><span class="token punctuation">,</span> y <span class="token builtin">int</span><span class="token punctuation">,</span> op operate<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> op <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">,</span> errors<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token string">"invalid operation"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token function">op</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">&#125;</span><span class="token keyword">type</span> calculateFunc <span class="token keyword">func</span><span class="token punctuation">(</span>x <span class="token builtin">int</span><span class="token punctuation">,</span> y <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span><span class="token keyword">func</span> <span class="token function">genCalculator</span><span class="token punctuation">(</span>op operate<span class="token punctuation">)</span> calculateFunc <span class="token punctuation">&#123;</span><span class="token keyword">if</span> op <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"op is err"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token keyword">func</span><span class="token punctuation">(</span>x <span class="token builtin">int</span><span class="token punctuation">,</span> y <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token function">op</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">Test2</span><span class="token punctuation">(</span>t <span class="token operator">*</span>testing<span class="token punctuation">.</span>T<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>diff<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> <span class="token function">calculate</span><span class="token punctuation">(</span><span class="token number">101</span><span class="token punctuation">,</span> <span class="token number">5898</span><span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> x <span class="token operator">-</span> y<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>t<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"101 - 5898 ="</span><span class="token punctuation">,</span> diff<span class="token punctuation">)</span>multiFunc <span class="token operator">:=</span> <span class="token function">genCalculator</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> x <span class="token operator">*</span> y<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>multiValue <span class="token operator">:=</span> <span class="token function">multiFunc</span><span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span>t<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"4 X 25 = "</span><span class="token punctuation">,</span> multiValue<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="函数传参"><a href="#函数传参" class="headerlink" title="函数传参"></a>函数传参</h3><p>值类型数据，每次传参会复制参数值，不会影响原始值（<strong>数组是值类型</strong>）<br>对于引用类型，比如：切片、字典、通道，像上面那样复制它们的值，只会拷贝它们本身而已，并不会拷贝它们引用的底层数据。也就是说，这时只是浅表复制，而不是深层复制。</p><h2 id="13-结构体及其方法的使用法门"><a href="#13-结构体及其方法的使用法门" class="headerlink" title="13 | 结构体及其方法的使用法门"></a>13 | 结构体及其方法的使用法门</h2><p>函数是独立的程序实体，可以声明有名字的函数也可以声明没有名字的函数。<br><strong>方法却不同，它需要有名字</strong>，不能被当作值来看待，最重要的是，它必须隶属于某一个类型。方法所属的类型会通过其声明中的接收者（receiver）声明体现出来。<br>接收者声明就是在关键字func和方法名称之间的圆括号包裹起来的内容，其中必须包含确切的名称和类型字面量。<br>接收者的类型其实就是当前方法所属的类型，而接收者的名称，则用于在当前方法中引用它所属的类型的当前值。<br>​</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// AnimalCategory 代表动物分类学中的基本分类法。</span><span class="token keyword">type</span> AnimalCategory d <span class="token punctuation">&#123;</span>kingdom <span class="token builtin">string</span> <span class="token comment">// 界。</span>phylum <span class="token builtin">string</span> <span class="token comment">// 门。</span>class  <span class="token builtin">string</span> <span class="token comment">// 纲。</span>order  <span class="token builtin">string</span> <span class="token comment">// 目。</span>family <span class="token builtin">string</span> <span class="token comment">// 科。</span>genus  <span class="token builtin">string</span> <span class="token comment">// 属。</span>species <span class="token builtin">string</span> <span class="token comment">// 种。</span><span class="token punctuation">&#125;</span> <span class="token keyword">func</span> <span class="token punctuation">(</span>ac AnimalCategory<span class="token punctuation">)</span> <span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"%s%s%s%s%s%s%s"</span><span class="token punctuation">,</span>ac<span class="token punctuation">.</span>kingdom<span class="token punctuation">,</span> ac<span class="token punctuation">.</span>phylum<span class="token punctuation">,</span> ac<span class="token punctuation">.</span>class<span class="token punctuation">,</span> ac<span class="token punctuation">.</span>order<span class="token punctuation">,</span>ac<span class="token punctuation">.</span>family<span class="token punctuation">,</span> ac<span class="token punctuation">.</span>genus<span class="token punctuation">,</span> ac<span class="token punctuation">.</span>species<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="嵌入字段"><a href="#嵌入字段" class="headerlink" title="嵌入字段"></a>嵌入字段</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Animal <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>scientificName <span class="token builtin">string</span> <span class="token comment">// 学名。</span>AnimalCategory    <span class="token comment">// 动物基本分类。</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>字段声明AnimalCategory代表了Animal类型的一个嵌入字段。</p><h4 id="调用嵌入字段的方式"><a href="#调用嵌入字段的方式" class="headerlink" title="调用嵌入字段的方式"></a>调用嵌入字段的方式</h4><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> a Animal<span class="token operator">...</span>a<span class="token punctuation">.</span>AnimalCategory <span class="token comment">// 引用AnimalCategory</span><span class="token keyword">func</span> <span class="token punctuation">(</span>a Animal<span class="token punctuation">)</span> <span class="token function">Category</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> a<span class="token punctuation">.</span>AnimalCategory<span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token punctuation">(</span>a Animal<span class="token punctuation">)</span> <span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token string">"这个方法会屏蔽掉嵌入类型的 String方法"</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="嵌入字段是一种组合的方式"><a href="#嵌入字段是一种组合的方式" class="headerlink" title="嵌入字段是一种组合的方式"></a>嵌入字段是一种组合的方式</h4><p>最后，再次强调，嵌入字段是实现类型间组合的一种方式，这与继承没有半点儿关系。Go 语言虽然支持面向对象编程，但是根本就没有“继承”这个概念。</p><h3 id="指针方法和值方法的区别"><a href="#指针方法和值方法的区别" class="headerlink" title="指针方法和值方法的区别"></a>指针方法和值方法的区别</h3><p>值方法</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>cat Cat<span class="token punctuation">)</span> <span class="token function">SetName</span><span class="token punctuation">(</span>name <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>指针方法</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>cat Cat<span class="token punctuation">)</span> <span class="token function">SetName</span><span class="token punctuation">(</span>name <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>cat<span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="值方法对元素值的修改不会体现在原值上"><a href="#值方法对元素值的修改不会体现在原值上" class="headerlink" title="值方法对元素值的修改不会体现在原值上"></a>值方法对元素值的修改不会体现在原值上</h4><p>值方法的接收者是该方法所属的那个类型值的一个副本。我们在该方法内对该副本的修改一般都不会体现在原值上，除非这个类型本身是某个引用类型（比如切片或字典）的别名类型。</p><h4 id="值类型的方法和指针类型的方法不在一个方法集合中"><a href="#值类型的方法和指针类型的方法不在一个方法集合中" class="headerlink" title="值类型的方法和指针类型的方法不在一个方法集合中"></a>值类型的方法和指针类型的方法不在一个方法集合中</h4><p>一个自定义数据类型的方法集合中仅会包含它的所有值方法，而该类型的指针类型的方法集合却囊括了前者的所有方法，包括所有值方法和所有指针方法。​<br>严格来讲，我们在这样的基本类型的值上只能调用到它的值方法。但是，Go 语言会适时地为我们进行自动地转译，使得我们在这样的值上也能调用到它的指针方法。<br>​</p><p>比如，在Cat类型的变量cat之上，之所以我们可以通过cat.SetName(“monster”)修改猫的名字，是因为 Go 语言把它自动转译为了(&amp;cat).SetName(“monster”)，即：先取cat的指针值，然后在该指针值上调用SetName方法。</p><h4 id="方法集合和接口实现有关，实现的指针方法，则只有指针类型才是接口的实现"><a href="#方法集合和接口实现有关，实现的指针方法，则只有指针类型才是接口的实现" class="headerlink" title="方法集合和接口实现有关，实现的指针方法，则只有指针类型才是接口的实现"></a>方法集合和接口实现有关，实现的指针方法，则只有指针类型才是接口的实现</h4><p>在后边你会了解到，一个类型的方法集合中有哪些方法与它能实现哪些接口类型是息息相关的。如果一个基本类型和它的指针类型的方法集合是不同的，那么它们具体实现的接口类型的数量就也会有差异，除非这两个数量都是零。​<br>比如，一个指针类型实现了某某接口类型，但它的基本类型却不一定能够作为该接口的实现类型。<br>​</p><h2 id="14-接口类型的合理运用"><a href="#14-接口类型的合理运用" class="headerlink" title="14 | 接口类型的合理运用"></a>14 | 接口类型的合理运用</h2><h3 id="前导"><a href="#前导" class="headerlink" title="前导"></a>前导</h3><p>接口类型声明中的这些方法所代表的就是该接口的方法集合。一个接口的方法集合就是它的全部特征。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Pet <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>    <span class="token function">SetName</span><span class="token punctuation">(</span>name <span class="token builtin">string</span><span class="token punctuation">)</span>    <span class="token function">Name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span>    <span class="token function">Category</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>只要一个数据类型的方法集合中有 SetName Name  Category 这三个方法，那么这个类型就是接口Pet的实现类型。</p><blockquote><p>这种实现方式叫做 Duck typing （鸭子类型）</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Dog <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>name <span class="token builtin">string</span> <span class="token comment">// 名字。</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token punctuation">(</span>dog <span class="token operator">*</span>Dog<span class="token punctuation">)</span> <span class="token function">SetName</span><span class="token punctuation">(</span>name <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>dog<span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token punctuation">(</span>dog Dog<span class="token punctuation">)</span> <span class="token function">Name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> dog<span class="token punctuation">.</span>name<span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token punctuation">(</span>dog Dog<span class="token punctuation">)</span> <span class="token function">Category</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token string">"dog"</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Dog 的值类型不是Pet的实现，Dog 的指针类型才是Pet的实现。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">dog <span class="token operator">:=</span> Dog<span class="token punctuation">&#123;</span><span class="token string">"littile pig"</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> pet Pet <span class="token operator">=</span> <span class="token operator">&amp;</span>dog<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>对于上面的代码来说：我们赋给pet的值 &amp;dog 称为他的实际值（也叫动态值），该值的类型叫做这个变量的实际类型（也称动态类型）<br>动态类型的叫法是相对于静态类型来讲的，对于pet来说他的静态类型就是Pet，并且永远是；动态类型会随着赋给它的值改变。在赋予接口类型值之前他的动态类型是不存在的。</p><h3 id="当我们为一个接口变量赋值时会发生什么？"><a href="#当我们为一个接口变量赋值时会发生什么？" class="headerlink" title="当我们为一个接口变量赋值时会发生什么？"></a>当我们为一个接口变量赋值时会发生什么？</h3><p>当我们给一个接口变量赋值的时候，该变量的动态类型会与它的动态值一起被存储在一个专用的数据结构中（iface）。然后将iface结构体的值赋给接口变量。</p><h4 id="接口组合"><a href="#接口组合" class="headerlink" title="接口组合"></a>接口组合</h4><p>接口组合时，同名的方法之间会发生冲突，无法通过编译</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Animal <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>    <span class="token function">ScientificName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span>    <span class="token function">Category</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span><span class="token punctuation">&#125;</span><span class="token keyword">type</span> Pet <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>    Animal    <span class="token function">Name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="15-关于指针的有限操作"><a href="#15-关于指针的有限操作" class="headerlink" title="15 | 关于指针的有限操作"></a>15 | 关于指针的有限操作</h2><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>从传统意义上来说，指针是一个指向某个确切的内存地址的值。这个内存地址可以是任何数据或代码的起始地址，比如某个变量，某个字段或某个函数。<br>GO语言中还有其他几样东西可以代表“指针”。<br>​</p><h3 id="unintptr"><a href="#unintptr" class="headerlink" title="unintptr"></a>unintptr</h3><p>该类型实际上是一个数值类型，也是Go语言内建的数据类型之一。<br>根据当前计算机的计算架构的不同，他可以存储32位或者64位的无符号整数，可以代表任何指针的位（bit）模式，也就是原始的内存地址。</p><h3 id="unsafe-Pointer"><a href="#unsafe-Pointer" class="headerlink" title="unsafe.Pointer"></a>unsafe.Pointer</h3><p>Go语言标准库中的unsafe包。unsafe包中有一个类型叫做Pointer，也代表“指针”<br>unsafe.Pointer可以表示任何指向可寻址的值的指针，同时他也是前边提到的指针值和unitptr之间的桥梁。也就是说，通过它，我们可以在这两种值上进行双向的转换，这里有一个很关键的词，可寻址的（addressable）。</p><h4 id="不可寻址的几种情况"><a href="#不可寻址的几种情况" class="headerlink" title="不可寻址的几种情况"></a>不可寻址的几种情况</h4><ol><li>不可变的值不可寻址。常量、基本类型的值字面量、字符串变量的值、函数以及方法的字面量以及对它们的调用表达式的<strong>结果值</strong>都是如此。其实这样规定也有安全性方面的考虑。</li><li>绝大多数被视为<strong>临时结果</strong>的值都是不可寻址的。算术操作的结果值属于临时结果，针对值字面量的表达式结果值也属于临时结果。但有一个例外，对切片字面量的索引结果值虽然也属于临时结果，但却是可寻址的。</li><li>若拿到某值的指针可能会破坏程序的一致性，那么就是<strong>不安全的</strong>，该值就不可寻址。由于字典的内部机制，对字典的索引结果值的取址操作都是不安全的。另外，获取由字面量或标识符代表的函数或方法的地址显然也是不安全的。</li></ol><h4 id="不可寻址值在使用上的限制"><a href="#不可寻址值在使用上的限制" class="headerlink" title="不可寻址值在使用上的限制"></a>不可寻址值在使用上的限制</h4><ol><li><p>无法使用 &amp; 获取指针</p></li><li><p>不能调用指针方法。因为无法转化为指针。</p></li><li><p>不能使用 ++ 或 – 表达式，不能作为赋值操作符和range操作符左边的表达式。字典字面量和字典变量索引表达式的结果值例外</p><h4 id="怎样通过unsafe-Pointer操纵可寻址的值"><a href="#怎样通过unsafe-Pointer操纵可寻址的值" class="headerlink" title="怎样通过unsafe.Pointer操纵可寻址的值"></a>怎样通过unsafe.Pointer操纵可寻址的值</h4><p>首先说明，这是一项黑科技。它可以绕过 Go 语言的编译器和其他工具的重重检查，并达到潜入内存修改数据的目的。这并不是一种正常的编程手段，使用它会很危险，很有可能造成安全隐患。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">dog <span class="token operator">:=</span> Dog<span class="token punctuation">&#123;</span><span class="token string">"little pig"</span><span class="token punctuation">&#125;</span>dogP <span class="token operator">:=</span> <span class="token operator">&amp;</span>dogdogPtr <span class="token operator">:=</span> <span class="token function">unitptr</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>dogP<span class="token punctuation">)</span><span class="token punctuation">)</span>namePtr <span class="token operator">:=</span> dogPtr <span class="token operator">+</span> unsafe<span class="token punctuation">.</span><span class="token function">Offsetof</span><span class="token punctuation">(</span>dogP<span class="token punctuation">.</span>name<span class="token punctuation">)</span>nameP <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token builtin">string</span><span class="token punctuation">)</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>namePtr<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码中的转换规则：</p></li><li><p>一个指针值（比如*Dog类型的值）可以被转换为一个unsafe.Pointer类型的值，反之亦然。</p></li><li><p>一个uintptr类型的值也可以被转换为一个unsafe.Pointer类型的值，反之亦然。</p></li><li><p>一个指针值无法被直接转换成一个uintptr类型的值，反过来也是如此。</p><h1 id="16-go语句及其执行规则（上）"><a href="#16-go语句及其执行规则（上）" class="headerlink" title="16 | go语句及其执行规则（上）"></a>16 | go语句及其执行规则（上）</h1><blockquote><p>Don’t communicate by sharing memory; share memory by communicating.<br>不要通过共享数据来通讯，恰恰相反，要以通讯的方式共享数据。</p></blockquote></li></ol><h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3><p>进程：程序的执行过程，是运行着的程序的代表。一个进程就是某个程序运行时的一个产物。<br>线程：线程总是在进程之内的，他可以被视为进程中运行着的控制流（或者说代码执行的流程）。每个进程的第一个线程都随着该进程的启动被创建，他们可以被称为器所属进程的主线程。主线程以外的进程都由进程中已存在的线程创建出来，由代码显示的创建和销毁。<br>Go 语言的运行时（runtime）系统会帮助我们自动地创建和销毁系统级的线程。这里的系统级线程指的就是我们刚刚说过的操作系统提供的线程。<br>Go语言中的<strong>用户级线程</strong>（goroutine）由Go语言程序控制，它们的创建和销毁并<strong>不用</strong>通过<strong>操作系统</strong>去做。</p><h3 id="Go语言的并发编程模型"><a href="#Go语言的并发编程模型" class="headerlink" title="Go语言的并发编程模型"></a>Go语言的并发编程模型</h3><p>G  ：goroutine，协程<br>P  ：processor， 调度器，负责调度协运行，申请系统资源<br>M ：machine， 系统级线程<br><img src="image2.png" alt="image2"></p><h3 id="协程的运行"><a href="#协程的运行" class="headerlink" title="协程的运行"></a>协程的运行</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main <span class="token keyword">import</span> <span class="token string">"fmt"</span> <span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>知识点1：启用协程后，主函数不会等待协程运行结束。主goroutine执行结束后，当前GO程序会直接结束运行。<br>知识点2：闭包中引用的变量是指针引用（或者说，闭包中的变量只有在被使用的时候才会被求值）</p><h2 id="17-go语句及其执行规则（下）"><a href="#17-go语句及其执行规则（下）" class="headerlink" title="17 | go语句及其执行规则（下）"></a>17 | go语句及其执行规则（下）</h2><h3 id="如何让主goroutine等待其他goroutine"><a href="#如何让主goroutine等待其他goroutine" class="headerlink" title="如何让主goroutine等待其他goroutine"></a>如何让主goroutine等待其他goroutine</h3><h4 id="方法一：让主goroutine小睡一会"><a href="#方法一：让主goroutine小睡一会" class="headerlink" title="方法一：让主goroutine小睡一会"></a>方法一：让主goroutine小睡一会</h4><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>MillionSecond <span class="token operator">*</span> <span class="token number">500</span><span class="token punctuation">)</span> <span class="token comment">//sleep等待500ms</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="方法二：通道"><a href="#方法二：通道" class="headerlink" title="方法二：通道"></a>方法二：通道</h4><pre class="line-numbers language-go" data-language="go"><code class="language-go">ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>        ch<span class="token operator">&lt;-</span><span class="token keyword">struct</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>    <span class="token operator">&lt;-</span>ch<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="方法三：使用Sync-WaitGroup"><a href="#方法三：使用Sync-WaitGroup" class="headerlink" title="方法三：使用Sync.WaitGroup"></a>方法三：使用Sync.WaitGroup</h4><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> wg sync<span class="token punctuation">.</span>WaitGroup<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>    wg<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>        wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="如何让goroutine顺序执行"><a href="#如何让goroutine顺序执行" class="headerlink" title="如何让goroutine顺序执行"></a>如何让goroutine顺序执行</h3><p>高级点的说法，这叫自旋</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> count <span class="token builtin">uint32</span>trigger <span class="token operator">:=</span> <span class="token keyword">func</span><span class="token punctuation">(</span>i <span class="token builtin">uint32</span><span class="token punctuation">,</span> fn <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">for</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> n <span class="token operator">:=</span> atomic<span class="token punctuation">.</span><span class="token function">LoadUint32</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">==</span> i <span class="token punctuation">&#123;</span>            <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            atomic<span class="token punctuation">.</span><span class="token function">AddUint32</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>count<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>            <span class="token keyword">break</span>        <span class="token punctuation">&#125;</span>        time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Nanosecond<span class="token punctuation">)</span><span class="token comment">//sleep 1纳秒</span>    <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">for</span> i <span class="token operator">=</span> <span class="token function">uint32</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span>i <span class="token builtin">uint32</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        fn <span class="token operator">:=</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>        <span class="token function">trigger</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> fn<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>        <span class="token function">trigger</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">//这里入参10 会让主程序最后结束</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="18-if语句、for语句和switch语句"><a href="#18-if语句、for语句和switch语句" class="headerlink" title="18 | if语句、for语句和switch语句"></a>18 | if语句、for语句和switch语句</h2><h3 id="for-range"><a href="#for-range" class="headerlink" title="for range"></a>for range</h3><h4 id="当使用一个返回值接收range时接收到的是迭代变量的索引"><a href="#当使用一个返回值接收range时接收到的是迭代变量的索引" class="headerlink" title="当使用一个返回值接收range时接收到的是迭代变量的索引"></a>当使用一个返回值接收range时接收到的是迭代变量的索引</h4><pre class="line-numbers language-go" data-language="go"><code class="language-go">numbers1 <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> index <span class="token operator">:=</span> <span class="token keyword">range</span> numbers1 <span class="token punctuation">&#123;</span>    fmt<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> <span class="token string">"  "</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// 输出为 0  1  2  3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="使用range时的注意事项"><a href="#使用range时的注意事项" class="headerlink" title="使用range时的注意事项"></a>使用range时的注意事项</h4><ol><li><p>range表达式只会在for语句开始执行时被求值一次，无论后边会有多少次迭代；</p></li><li><p>range表达式的求值结果会被复制，也就是说，被迭代的对象是range表达式结果值的副本而不是原值。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">numbers2 <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">&#125;</span>maxIndex <span class="token operator">=</span> <span class="token function">len</span><span class="token punctuation">(</span>numbers2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token number">1</span><span class="token keyword">for</span> i<span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> numbers2 <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> i <span class="token operator">==</span> maxIndex <span class="token punctuation">&#123;</span>    numbers2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+=</span> v    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    numbers2<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+=</span> v    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>numbers2<span class="token punctuation">)</span><span class="token comment">// 输出  [7 3 5 7 9 11]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="使用-range-迭代切片时情况不同，引用值复制的是引用"><a href="#使用-range-迭代切片时情况不同，引用值复制的是引用" class="headerlink" title="使用 range 迭代切片时情况不同，引用值复制的是引用"></a>使用 range 迭代切片时情况不同，引用值复制的是引用</h4><pre class="line-numbers language-go" data-language="go"><code class="language-go">numbers3 <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">&#125;</span>maxIndex <span class="token operator">=</span> <span class="token function">len</span><span class="token punctuation">(</span>numbers3<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token number">1</span><span class="token keyword">for</span> i<span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> numbers3 <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> i <span class="token operator">==</span> maxIndex <span class="token punctuation">&#123;</span>    numbers3<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+=</span> v    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    numbers3<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+=</span> v    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>numbers3<span class="token punctuation">)</span><span class="token comment">// 输出 [22 3 6 10 15 21]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="在range中获取迭代元素引用"><a href="#在range中获取迭代元素引用" class="headerlink" title="在range中获取迭代元素引用"></a>在range中获取迭代元素引用</h4><pre class="line-numbers language-go" data-language="go"><code class="language-go">numbers3 <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">&#125;</span>numbers4 <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>maxIndex <span class="token operator">=</span> <span class="token function">len</span><span class="token punctuation">(</span>numbers3<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token number">1</span><span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> e <span class="token operator">:=</span> <span class="token keyword">range</span> numbers3 <span class="token punctuation">&#123;</span>    numbers4<span class="token operator">=</span><span class="token function">append</span><span class="token punctuation">(</span>numbers4<span class="token punctuation">,</span> <span class="token operator">&amp;</span>e<span class="token punctuation">)</span><span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>numbers4<span class="token punctuation">)</span> <span class="token comment">//里边所有的元素都是 0x14000016118</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3></li><li><p>switch语句对switch表达式的结果类型，以及各个case表达式中子表达式的结果类型都是有要求的。毕竟，在 Go 语言中，只有类型相同的值之间才有可能被允许进行判等操作。</p></li><li><p>switch语句不允许case表达式中的子表达式结果值存在相等的情况</p></li></ol><p>​</p><h2 id="19-错误处理（上）"><a href="#19-错误处理（上）" class="headerlink" title="19 | 错误处理（上）"></a>19 | 错误处理（上）</h2><p>没啥东西 略。。。。</p><h2 id="20-错误处理（下）"><a href="#20-错误处理（下）" class="headerlink" title="20 | 错误处理（下）"></a>20 | 错误处理（下）</h2><p>扁平的错误体系和立体的错误体系<br>​</p><h2 id="21-panic函数、recover函数以及defer语句（上）"><a href="#21-panic函数、recover函数以及defer语句（上）" class="headerlink" title="21 | panic函数、recover函数以及defer语句（上）"></a>21 | panic函数、recover函数以及defer语句（上）</h2><p>没啥东西  略。。。</p><h2 id="22-panic函数、recover函数以及defer语句（下）"><a href="#22-panic函数、recover函数以及defer语句（下）" class="headerlink" title="22  | panic函数、recover函数以及defer语句（下）"></a>22  | panic函数、recover函数以及defer语句（下）</h2><p>多个defer的运行顺序是后进先出</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过nginx实现逐步上线重构系统</title>
      <link href="2021/03/21/zui-jia-shi-jian/tong-guo-nginx-shi-xian-zhu-bu-shang-xian-chong-gou-xi-tong/"/>
      <url>2021/03/21/zui-jia-shi-jian/tong-guo-nginx-shi-xian-zhu-bu-shang-xian-chong-gou-xi-tong/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="00-背景"><a href="#00-背景" class="headerlink" title="00 背景"></a>00 背景</h2><p>公司现有一个历史遗留项目，项目为 <code>PHP5.6</code>+<code>Smart</code> 构建的单站点应用。现使用 <code>Laravel</code> + <code>Vue</code> 重构为前后端分离项目。<br>为减小一次性上线风险，使用nginx反向代理能力，分模块逐步上线重构后的项目。</p><h2 id="01-操作方法"><a href="#01-操作方法" class="headerlink" title="01 操作方法"></a>01 操作方法</h2><blockquote><p>nginx 规则：<a href="https://moonbingbing.gitbooks.io/openresty-best-practices/content/ngx/nginx_local_pcre.html">https://moonbingbing.gitbooks.io/openresty-best-practices/content/ngx/nginx_local_pcre.html</a><br>通过nginx代理规则，将新项目的路由通过老项目域名代理</p></blockquote><pre class="line-numbers language-none"><code class="language-none">location ~ &#x2F;(center|vendor|favicon|cost) &#123;    proxy_pass https:&#x2F;&#x2F;new.domain.com;    proxy_set_header X-Real-IP $remote_addr;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://new.domain.com/">https://new.domain.com</a> 是 重构后前端项目的域名。 vendor 和 favicon 是前端项目的资源路径。<br>此时，当浏览器请求指定路由时，就会将请求代理至前端项目。</p><h2 id="02-其他方法"><a href="#02-其他方法" class="headerlink" title="02 其他方法"></a>02 其他方法</h2><p>如果项目使用了 k8s 并且前后端项目在同一个命名空间下可以通过配置 <code>ingress</code> 来代替 配置项目的<code>nginx</code>。本次重构因前后端项目不在同一命名空间故未使用此方法。</p>]]></content>
      
      
      <categories>
          
          <category> 最佳实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工程实践 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis源码之SDS</title>
      <link href="2021/03/17/redis/redis-yuan-ma-zhi-sds/"/>
      <url>2021/03/17/redis/redis-yuan-ma-zhi-sds/</url>
      
        <content type="html"><![CDATA[<h2 id="写在之前"><a href="#写在之前" class="headerlink" title="写在之前"></a>写在之前</h2><p>本文中大量图片及内容引用自陈雷老师和他的团队所著的《Redis5设计与源码分析》以及 黄健宏老师所著的《Redis设计与实现》。</p><h2 id="我们为什么要学习Redis底层源码"><a href="#我们为什么要学习Redis底层源码" class="headerlink" title="我们为什么要学习Redis底层源码"></a>我们为什么要学习Redis底层源码</h2><ol><li>对技术的卓越追求：每一个程序员都应该对技术有所追求，每天单纯的只写业务代码难以提高自身技术深度。通过阅读源码可以大大提高我们自身的技术深度。</li><li>更加熟练的运用工具：无论是语言还是数据库都是我们生产的工具，通过阅读源码了解原理，可以做到知其然，更知其所以然。更加熟练的实用工具。</li><li>提升代码水平：Redis的设计非常的精妙，如各种数据结构的设计，以及网络模型实现等。通过学习他的代码思想，能给我们程序的编写带来很大的帮助。</li><li>解开计算机运行的神秘面纱：大多数开源软件的源码都是由C一类基础的语言来实现的，其中必定涉及了大量对内存和系统调度等的操作。<blockquote><p>Redis 的设计非常简洁、优美、精巧和高效， 任何人只要愿意去阅读它的代码的话， 应该都会有所收获的。    –黄健宏（huangz)  2014.7.28</p></blockquote></li></ol><h2 id="SDS是什么"><a href="#SDS是什么" class="headerlink" title="SDS是什么"></a>SDS是什么</h2><blockquote><p>SDS是简单动态字符串（simple dynamic string）的缩写，Redis使用SDS来存储有可能发生改变的字符串（如：各种类型数据的“键”，字符串类型的值，list中的各个元素的值等等）</p></blockquote><ul><li>如：当我们执行 <code>set msg &quot;hello world&quot;</code> Redis会为我们创建两个字符串对象，分别是保存着<code>msg</code> 和 <code>hello world</code> 的SDS。</li><li>又比如：<code>lpush goods_list &quot;SN001&quot; &quot;SN002&quot; &quot;SN003&quot;</code>Redis将会创建一个键为<code>goods_list</code>，值为一个 <code>列表对象</code> 的键值对：键是一个保存着 <code>goods_list</code>的SDS，列表对象中包含着三个字符串对象，分别由三个SDS实现。<blockquote><p>除了用来保存数据库中的字符串值之外，SDS还被用作缓冲区（buffer）：AOF模块中的AOF缓冲区，以及客户端状态中的输入缓冲区 –黄健宏 著. Redis设计与实现 </p></blockquote></li></ul><h2 id="SDS的构造以及与C字符串的区别（结合Redis3源码讲解）"><a href="#SDS的构造以及与C字符串的区别（结合Redis3源码讲解）" class="headerlink" title="SDS的构造以及与C字符串的区别（结合Redis3源码讲解）"></a>SDS的构造以及与C字符串的区别（结合Redis3源码讲解）</h2><p>SDS 相关代码在 sds.h 与 sds.c 中</p><h3 id="Redis3中SDS的构造"><a href="#Redis3中SDS的构造" class="headerlink" title="Redis3中SDS的构造"></a>Redis3中SDS的构造</h3><ol><li>代码实现（代码位于sds.h/sdshdr）<pre class="line-numbers language-none"><code class="language-none">&#x2F;* * 保存字符串对象的结构 *&#x2F;struct sdshdr &#123;        &#x2F;&#x2F; buf 中已占用空间的长度    int len;    &#x2F;&#x2F; buf 中剩余可用空间的长度    int free;    &#x2F;&#x2F; 数据空间    char buf[];&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>柔性数组：柔性数组成员（flexible array member），也叫伸缩性数组成员，只能被放在结构体的末尾。包含柔性数组成员的结构体，通过malloc函数为柔性数组动态分配内存。<br>柔性数组的地址和结构体是连续的。由于这个特性可以很方便的通过偏移柔型数组的首地址来找到结构体中的其余变量。</p></blockquote></li><li>SDS结构<br><img src="sds-struct.png" alt="sds结构"></li></ol><p><em>len、free、和buf是相连的</em><br>3. SDS 示例<br><img src="sds-ex1.png" alt="SDS示例1"><br>可以看到，SDS遵循C字符串以空字符结尾的惯例，保存空字符的1字节空间不计算在SDS的len属性里面。这样做的好处是可以重用C中字符串函数。<br><img src="sds-ex2.png" alt="SDS示例1"><br>这个SDS同样保存了字符串<code>Redis</code> 但是为SDS额外分配了5字节的空间，所以free=5</p><h3 id="与C字符串的比较："><a href="#与C字符串的比较：" class="headerlink" title="与C字符串的比较："></a>与C字符串的比较：</h3><ol><li>常数复杂度获取长度<ul><li>因为C字符串并不记录自身的长度信息，所以为了获取一个C字符串的长度，程序必须遍历整个字符串，对遇到的每个字符进行计数，直到遇到代表字符串结尾的空字符（’\0’）为止，这个操作的复杂度为O（N）。</li><li>而SDS只需要访问len属性即可得到字符串长度<pre class="line-numbers language-none"><code class="language-none">&#x2F;** 返回 sds 实际保存的字符串的长度** T &#x3D; O(1)*&#x2F;static inline size_t sdslen(const sds s) &#123;    struct sdshdr *sh &#x3D; (void*)(s-(sizeof(struct sdshdr)));    return sh-&gt;len;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li>避免缓冲区溢出<ul><li>对C语言的字符串进行拼接操作时，如果拼接后的字符串长度超出字符串容量，那么会改变字符数组之外的内容。</li><li>而SDS API会在修改前对buf的大小进行判断（根据free）如果空间不足会先拓展空间，再执行拼接。</li></ul></li><li>减少了修改字符串时的内存分配次数<ol><li>空间预分配<blockquote><p>空间预分配用于优化SDS的字符串增长操作：当SDS的API对一个SDS进行修改，并且需要对SDS进行空间扩展的时候，程序不仅会为SDS分配修改所必须要的空间，还会为SDS分配额外的未使用空间。</p></blockquote></li></ol><ul><li>redis3.0的分配策略： 如果修改后的长度小于1MB将会额外分配和len属性相同长度的空间；如果大于1MB将会额外分配1MB空间<blockquote><p>通过这种预分配策略，SDS将连续增长N次字符串所需的内存重分配次数从必定N次降低为最多N次。</p></blockquote></li></ul><ol start="2"><li>惰性空间释放<br>当SDS中存储的字符串长度缩短时，将回收多余的空间，而是使用free记录下来，以备下次使用<blockquote><p>通过惰性空间释放策略，SDS避免了缩短字符串时所需的内存重分配操作，并为将来可能有的增长操作提供了优化。</p></blockquote></li></ol></li><li>二进制安全</li></ol><ul><li>C 语言字符串会将空字符 ‘\n’ 认为是字符串的结束，如果向字符串中存储  <code>char* s = &quot;hello \0 whorld!&quot;</code>那么最终 s 的值仅为“hello” 会抛弃掉’\0’之后的部分，因此只能存储文本不能保存图片音视频等二进制数据。</li><li>而SDS使用 len 来判断字符串的长度 而不是根据 ‘\0’来判断字符串是否结束。<blockquote><p>SDS的API都是二进制安全的（binarysafe），所有SDS API都会以处理二进制的方式来处理SDS存放在buf数组里的数据</p></blockquote></li></ul><h3 id="SDS和C字符串差异对照"><a href="#SDS和C字符串差异对照" class="headerlink" title="SDS和C字符串差异对照"></a>SDS和C字符串差异对照</h3><table><thead><tr><th align="center">c字符串</th><th align="center">SDS</th></tr></thead><tbody><tr><td align="center">获取字符串长度的复杂度为O(N)</td><td align="center">获取字符串长度的复杂度为O(1)</td></tr><tr><td align="center">API是不安全的，可能会造成缓冲区溢出</td><td align="center">API是安全的不会造成缓冲区溢出</td></tr><tr><td align="center">修改字符串长度N次必然需要进行N次长度分配</td><td align="center">修改字符串长度N次最多需要进行N次内存重新分配</td></tr><tr><td align="center">只能保存文本数据</td><td align="center">可以保存文本或者二进制数据</td></tr><tr><td align="center">可以使用所有&lt;string.h&gt;库中的函数</td><td align="center">可以使用一部分&lt;string.h&gt;库中的函数</td></tr></tbody></table><h2 id="Redis5对SDS的优化"><a href="#Redis5对SDS的优化" class="headerlink" title="Redis5对SDS的优化"></a>Redis5对SDS的优化</h2><ol><li>原来的SDS存在的问题<ul><li>头部占用空间太大，即使存储1字节长度的字符也需要 4(int len) + 4(int free) + 1(字符串内容) 的空间，大多数情况下都用不到4个字节的空间来存储长度</li></ul></li><li>Redis5对SDS的优化<ul><li>Redis5 将字符串根据长度区分为 5 种，分别为</li></ul></li></ol><pre class="line-numbers language-none"><code class="language-none">#define SDS_TYPE_5  0  &#x2F;&#x2F; 用5位就可以存储长度， 最大长度为 2^5 - 1#define SDS_TYPE_8  1  &#x2F;&#x2F; 最大长度为2^8 - 1#define SDS_TYPE_16 2  &#x2F;&#x2F; 最大长度为2^16 - 1#define SDS_TYPE_32 3  &#x2F;&#x2F; 最大长度为2^32 - 1#define SDS_TYPE_64 4  &#x2F;&#x2F; 最大长度为2^64 - 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>对于长度小于32的短字符串，5 位即可将长度存储，再用 3 位来存储字符串类型（0，1，2，3，4）。这样只需要使用1个字节就可以存储这两个内容：</li></ol><pre class="line-numbers language-none"><code class="language-none">struct __attribute__ ((__packed__))sdshdr5 &#123;  unsigned char flags; &#x2F;* 低3位存储类型, 高5位存储长度 *&#x2F;  char buf[];&#x2F;*柔性数组, 存放实际内容*&#x2F;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>结构如下图<br><img src="sdshdr5.png" alt="SDSHDR5"><br>sdshdr5结构中，flags占1个字节，其低3位（bit）表示type，高5位（bit）表示长度，能表示的长度区间为0～31（2^5-1），flags后面就是字符串的内容。<br>2. 对于长度大于31的字符串将len 和 free 单独存放。 sdshdr8,sdshdr16,sdshdr32,sdshdr64的结构相同，sdshdr16的结构如下所示<br><img src="sdshdr16.png" alt="SDSHDR16"><br>1）len：表示buf中已占用字节数。<br>2）alloc：表示buf中已分配字节数，不同于free，记录的是为buf分配的总长度。<br>3）flags：标识当前结构体的类型，低3位用作标识位，高5位预留。<br>4）buf：柔性数组，真正存储字符串的数据空间。</p><p>在Redis 5.0中，sdshdr8、sdshdr16、sdshdr32和sdshdr64的数据结构如下：   </p><pre class="line-numbers language-none"><code class="language-none">struct __attribute__((__packed__))sdshdr8 &#123;  uint8_t len; &#x2F;* 已使用长度, 用1字节存储 *&#x2F;  uint8_t alloc; &#x2F;* 总长度, 用1字节存储*&#x2F;  unsigned char flags; &#x2F;* 低3位存储类型, 高5位预留 *&#x2F;  char buf[];&#x2F;*柔性数组, 存放实际内容*&#x2F;&#125;;struct __attribute__((__packed__))sdshdr16 &#123;  uint16_t len; &#x2F;*已使用长度, 用2字节存储*&#x2F;  uint16_t alloc; &#x2F;* 总长度, 用2字节存储*&#x2F;  unsigned char flags; &#x2F;* 低3位存储类型, 高5位预留 *&#x2F;  char buf[];&#x2F;*柔性数组, 存放实际内容*&#x2F;&#125;;struct __attribute__((__packed__))sdshdr32 &#123;  uint32_t len; &#x2F;*已使用长度, 用4字节存储*&#x2F;  uint32_t alloc; &#x2F;* 总长度, 用4字节存储*&#x2F;  unsigned char flags;&#x2F;* 低3位存储类型, 高5位预留 *&#x2F;  char buf[];&#x2F;*柔性数组, 存放实际内容*&#x2F;&#125;;struct __attribute__((__packed__))sdshdr64 &#123;  uint64_t len; &#x2F;*已使用长度, 用8字节存储*&#x2F;  uint64_t alloc; &#x2F;* 总长度, 用8字节存储*&#x2F;  unsigned char flags; &#x2F;* 低3位存储类型, 高5位预留 *&#x2F;  char buf[];&#x2F;*柔性数组, 存放实际内容*&#x2F;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><em>一般情况下，结构体会按其所有变量大小的最小公倍数做字节对齐，而用packed修饰后，结构体则变为按1字节对齐</em></p></blockquote><p><img src="packed.png" alt="packed修饰"><br>这样做一方面节省了空间，另一方面保证了柔性数组紧跟在flags之后，可以通过偏移柔性数组指针来找到</p><h2 id="SDS操作API（部分）"><a href="#SDS操作API（部分）" class="headerlink" title="SDS操作API（部分）"></a>SDS操作API（部分）</h2><h3 id="新建"><a href="#新建" class="headerlink" title="新建"></a>新建</h3><pre class="line-numbers language-none"><code class="language-none">sds sdsnewlen(const void *init, size_t initlen) &#123;    void *sh;    sds s;    char type &#x3D; sdsReqType(initlen);&#x2F;&#x2F;根据字符串长度选择不同的类型    if (type &#x3D;&#x3D; SDS_TYPE_5 &amp;&amp; initlen &#x3D;&#x3D; 0) type &#x3D; SDS_TYPE_8;&#x2F;&#x2F;SDS_TYPE_5强制转化为SDS_TYPE_8    int hdrlen &#x3D; sdsHdrSize(type);&#x2F;&#x2F;计算不同头部所需的长度    unsigned char *fp; &#x2F;* 指向flags的指针 *&#x2F;    sh &#x3D; s_malloc(hdrlen+initlen+1);&#x2F;&#x2F;&quot;+1&quot;是为了结束符&#39;\0&#39;    ...    s &#x3D; (char*)sh+hdrlen;&#x2F;&#x2F;s是指向buf的指针    fp &#x3D; ((unsigned char*)s)-1;&#x2F;&#x2F;s是柔性数组buf的指针,-1即指向flags    ...    s[initlen] &#x3D; &#39;\0&#39;;&#x2F;&#x2F;添加末尾的结束符    return s;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>Redis 3.2后的SDS结构由1种增至5种，且对于sdshdr5类型，在创建<code>空字符串</code>时会强制转换为sdshdr8。原因可能是创建空字符串后，其内容可能会频繁更新而引发扩容，故创建时直接创建为sdshdr8。<br>从源码中我们可以看到，其实s就是一个字符数组的指针，即结构中的buf。这样设计的好处在于直接对上层提供了字符串内容指针，兼容了部分C函数，且通过偏移能迅速定位到SDS结构体的各处成员变量。</p></blockquote><h3 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h3><ul><li>真正释放内存：这种方法通过移动<code>s</code>将指针定位到SDS首部，然后使用s_free将内存释放<pre class="line-numbers language-none"><code class="language-none">void sdsfree(sds s) &#123;  if (s &#x3D;&#x3D; NULL) return;  s_free((char*)s-sdsHdrSize(s[-1]));&#x2F;&#x2F;此处直接释放内存&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li>重置值而不释放内存：此方法可以将SDS的len归零，但不释放内存，新的数据可以覆盖写入到buf中，减少了申请内存的开销。<pre class="line-numbers language-none"><code class="language-none">void sdsclear(sds s) &#123;  sdssetlen(s, 0); &#x2F;&#x2F;统计值len归零  s[0] &#x3D; &#39;\0&#39;;&#x2F;&#x2F;清空buf&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h3>拼接操作可以通过调用<code>sdscatsds</code>方法来完成，<code>sdscatsds</code>是暴露给上层的方法，在方法中调用了<code>sdscatlen</code>来完成对字符串的拼接。<br>因为拼接后的字符串长度有可能大于当前SDS类型的容量，所以在<code>sdscatlen</code>方法中调用了<code>sdsMakeRoomFor</code>来判断是否需要扩容，如果不需要扩容就返回原来的字符串，如果需要扩容就返回扩容好的新字符串* 。<br>SDS的扩容策略：</li></ul><ol><li>若sds中剩余空闲长度大于新增内容的长度addlen，直接在柔性数组buf末尾追加即可，无须扩容。</li><li>若sds中剩余空闲长度avail小于或等于新增内容的长度addlen，则分情况讨论：新增后总长度len+addlen&lt;1MB的，按新长度的2倍扩容；新增后总长度len+addlen&gt;1MB的，按新长度加上1MB扩容。<pre class="line-numbers language-none"><code class="language-none">sds sdscatsds(sds s, const sds t) &#123;  return sdscatlen(s, t, sdslen(t));&#125;&#x2F;* 这是一个二进制安全的方法，功能是将指针t的内容和指针s的内容拼接在一起*&#x2F;sds sdscatlen(sds s, const void *t, size_t len) &#123;  size_t curlen &#x3D; sdslen(s);  s &#x3D; sdsMakeRoomFor(s,len); &#x2F;&#x2F;这里进行了扩容的判断操作  if (s &#x3D;&#x3D; NULL) return NULL;  memcpy(s+curlen, t, len);&#x2F;&#x2F;直接拼接, 保证了二进制安全  sdssetlen(s, curlen+len);  s[curlen+len] &#x3D; &#39;\0&#39;;&#x2F;&#x2F;加上结束符  return s;&#125;&#x2F;*判断sds是否需要扩容，如果不需要扩容就返回原来的字符串，如果需要扩容就返回扩容好的新字符串*&#x2F;sds sdsMakeRoomFor(sds s, size_t addlen) &#123;    void *sh, *newsh;    size_t avail &#x3D; sdsavail(s);&#x2F;&#x2F;此处返回的是SDS中剩余空闲长度    size_t len, newlen;    char type, oldtype &#x3D; s[-1] &amp; SDS_TYPE_MASK;  &#x2F;&#x2F;这里的 取得的是 SDS的类型 SDS_TYPE_MASK &#x3D; 7 &#x3D;&gt; 00000111    int hdrlen;    &#x2F;* Return ASAP if there is enough space left. *&#x2F;    if (avail &gt;&#x3D; addlen) return s;    len &#x3D; sdslen(s);    sh &#x3D; (char*)s-sdsHdrSize(oldtype);    newlen &#x3D; (len+addlen);    if (newlen &lt; SDS_MAX_PREALLOC)        newlen *&#x3D; 2;    else        newlen +&#x3D; SDS_MAX_PREALLOC;    type &#x3D; sdsReqType(newlen);    &#x2F;* Don&#39;t use type 5: the user is appending to the string and type 5 is     * not able to remember empty space, so sdsMakeRoomFor() must be called     * at every appending operation. *&#x2F;    if (type &#x3D;&#x3D; SDS_TYPE_5) type &#x3D; SDS_TYPE_8;    hdrlen &#x3D; sdsHdrSize(type);    if (oldtype&#x3D;&#x3D;type) &#123;        newsh &#x3D; s_realloc(sh, hdrlen+newlen+1);        if (newsh &#x3D;&#x3D; NULL) return NULL;        s &#x3D; (char*)newsh+hdrlen;    &#125; else &#123;        &#x2F;* Since the header size changes, need to move the string forward,         * and can&#39;t use realloc *&#x2F;        newsh &#x3D; s_malloc(hdrlen+newlen+1);        if (newsh &#x3D;&#x3D; NULL) return NULL;        memcpy((char*)newsh+hdrlen, s, len+1);        s_free(sh);        s &#x3D; (char*)newsh+hdrlen;        s[-1] &#x3D; type;        sdssetlen(s, len);    &#125;    sdssetalloc(s, newlen);    return s;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Laravel事件浅析</title>
      <link href="2021/03/15/laravel/laravel-shi-jian-qian-xi/"/>
      <url>2021/03/15/laravel/laravel-shi-jian-qian-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="Laravel-事件源码浅析"><a href="#Laravel-事件源码浅析" class="headerlink" title="Laravel 事件源码浅析"></a>Laravel 事件源码浅析</h2><h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h3><p>需要了解以下基础知识：</p><ul><li>Laravel 事件系统：<a href="https://learnku.com/docs/laravel/5.5/events/1318">https://learnku.com/docs/laravel/5.5/events/1318</a></li><li>Facades：<a href="https://learnku.com/docs/laravel/5.5/facades/1291">https://learnku.com/docs/laravel/5.5/facades/1291</a></li><li>服务提供者：<a href="https://learnku.com/docs/laravel/5.5/providers/1290">https://learnku.com/docs/laravel/5.5/providers/1290</a><h3 id="二-监听者注册和事件触发方式"><a href="#二-监听者注册和事件触发方式" class="headerlink" title="二. 监听者注册和事件触发方式"></a>二. 监听者注册和事件触发方式</h3></li></ul><h4 id="注册监听"><a href="#注册监听" class="headerlink" title="注册监听"></a>注册监听</h4><ol><li>在<code>App\Providers\EventServiceProvider</code> 的 <code>$listen</code> 数组中增加事件类和监听者类的映射。</li><li>在<code>App\Providers\EventServiceProvider</code> 的 <code>boot()</code> 方法中设置基于字符串（事件名）和闭包（监听方法）的监听。</li><li>在自定义的订阅者中可以监听多个事件，订阅者需要在 <code>App\Providers\EventServiceProvider</code> 的 <code>$subscribe</code> 属性中注册。</li></ol><h4 id="事件触发"><a href="#事件触发" class="headerlink" title="事件触发"></a>事件触发</h4><p>使用辅助方法 <code>event()</code> 触发事件。</p><h3 id="三-核心事件类的注册"><a href="#三-核心事件类的注册" class="headerlink" title="三. 核心事件类的注册"></a>三. 核心事件类的注册</h3><p>通过追踪 <code>\App\Providers\EventServiceProvider</code> 类，发现其继承 <code>Illuminate\Foundation\Support\Providers\EventServiceProvider</code></p><p><code>Illuminate\Foundation\Support\Providers\EventServiceProvider</code> 类通过调用 <code>Event</code> 门面的 <code>listen()</code> 和 <code>subscribe()</code>方法完成对事件的订阅。</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">boot</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-></span><span class="token function">listens</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token variable">$event</span> <span class="token operator">=></span> <span class="token variable">$listeners</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token variable">$listeners</span> <span class="token keyword">as</span> <span class="token variable">$listener</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name static-context">Event</span><span class="token operator">::</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token variable">$event</span><span class="token punctuation">,</span> <span class="token variable">$listener</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-></span><span class="token property">subscribe</span> <span class="token keyword">as</span> <span class="token variable">$subscriber</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name static-context">Event</span><span class="token operator">::</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token variable">$subscriber</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="Event-门面核心代码如下："><a href="#Event-门面核心代码如下：" class="headerlink" title="Event 门面核心代码如下："></a>Event 门面核心代码如下：</h5><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token comment">/** * @see \Illuminate\Events\Dispatcher */</span><span class="token keyword">class</span> <span class="token class-name">Event</span> <span class="token keyword">extends</span> <span class="token class-name">Facade</span><span class="token punctuation">&#123;</span>  <span class="token comment">//........</span>    <span class="token comment">/**     * Get the registered name of the component.     *     * @return string     */</span>    <span class="token keyword">protected</span> <span class="token keyword">static</span> <span class="token keyword">function</span> <span class="token function">getFacadeAccessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token string single-quoted-string">'events'</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里的 <code>events</code> 就是 Laravel 的事件监听器， 注册于 <code>\Illuminate\Foundation\Application:193</code>:</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token keyword">protected</span> <span class="token keyword">function</span> <span class="token function">registerBaseServiceProviders</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token variable">$this</span><span class="token operator">-></span><span class="token function">register</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">EventServiceProvider</span><span class="token punctuation">(</span><span class="token variable">$this</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>\Illuminate\Events\EventServiceProvider</code> :</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token keyword">class</span> EventServiceProvider <span class="token keyword">extends</span> <span class="token class-name">ServiceProvider</span><span class="token punctuation">&#123;</span>    <span class="token comment">/**     * Register the service provider.     *     * @return void     */</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">register</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token variable">$this</span><span class="token operator">-></span><span class="token property">app</span><span class="token operator">-></span><span class="token function">singleton</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'events'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token variable">$app</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Dispatcher</span><span class="token punctuation">(</span><span class="token variable">$app</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">setQueueResolver</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">use</span> <span class="token punctuation">(</span><span class="token variable">$app</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> <span class="token variable">$app</span><span class="token operator">-></span><span class="token function">make</span><span class="token punctuation">(</span><span class="token class-name static-context">QueueFactoryContract</span><span class="token operator">::</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>去除掉绑定队列实现的操作，核心代码如下：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token variable">$this</span><span class="token operator">-></span><span class="token property">app</span><span class="token operator">-></span><span class="token function">singleton</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'events'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token variable">$app</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Dispatcher</span><span class="token punctuation">(</span><span class="token variable">$app</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可见，事件服务的核心类就是 <code>\Illuminate\Events\Dispatcher</code> 。</p><h3 id="四-事件监听的注册"><a href="#四-事件监听的注册" class="headerlink" title="四. 事件监听的注册"></a>四. 事件监听的注册</h3><p>结合上边 <code>Illuminate\Foundation\Support\Providers\EventServiceProvider</code> 的内容:</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-></span><span class="token function">listens</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token variable">$event</span> <span class="token operator">=></span> <span class="token variable">$listeners</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token variable">$listeners</span> <span class="token keyword">as</span> <span class="token variable">$listener</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token class-name static-context">Event</span><span class="token operator">::</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token variable">$event</span><span class="token punctuation">,</span> <span class="token variable">$listener</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-></span><span class="token property">subscribe</span> <span class="token keyword">as</span> <span class="token variable">$subscriber</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name static-context">Event</span><span class="token operator">::</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token variable">$subscriber</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出事件的监听是依赖 <code>Dispatcher</code> 的 <code>listen()</code> 方法 和 <code>subscribe()</code> 方法实现的：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">listen</span><span class="token punctuation">(</span><span class="token variable">$events</span><span class="token punctuation">,</span> <span class="token variable">$listener</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword type-casting">array</span><span class="token punctuation">)</span> <span class="token variable">$events</span> <span class="token keyword">as</span> <span class="token variable">$event</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name static-context">Str</span><span class="token operator">::</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token variable">$event</span><span class="token punctuation">,</span> <span class="token string single-quoted-string">'*'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token variable">$this</span><span class="token operator">-></span><span class="token function">setupWildcardListen</span><span class="token punctuation">(</span><span class="token variable">$event</span><span class="token punctuation">,</span> <span class="token variable">$listener</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>          <span class="token variable">$this</span><span class="token operator">-></span><span class="token property">listeners</span><span class="token punctuation">[</span><span class="token variable">$event</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$this</span><span class="token operator">-></span><span class="token function">makeListener</span><span class="token punctuation">(</span><span class="token variable">$listener</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token variable">$subscriber</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token variable">$subscriber</span> <span class="token operator">=</span> <span class="token variable">$this</span><span class="token operator">-></span><span class="token function">resolveSubscriber</span><span class="token punctuation">(</span><span class="token variable">$subscriber</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$subscriber</span><span class="token operator">-></span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token variable">$this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>根据监听事件的模式不同，储存至不同的属性中：</p><ol><li>当 事件名 中包含 <code>*</code> 时，认为是 通配符事件监听，将会把事件监听映射存储至 <code>$wildcards</code> 属性。</li></ol><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token keyword">protected</span> <span class="token keyword">function</span> <span class="token function">setupWildcardListen</span><span class="token punctuation">(</span><span class="token variable">$event</span><span class="token punctuation">,</span> <span class="token variable">$listener</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token variable">$this</span><span class="token operator">-></span><span class="token property">wildcards</span><span class="token punctuation">[</span><span class="token variable">$event</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$this</span><span class="token operator">-></span><span class="token function">makeListener</span><span class="token punctuation">(</span><span class="token variable">$listener</span><span class="token punctuation">,</span> <span class="token constant boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>否则会将事件监听映射存储至 <code>$listeners</code> 属性。</li></ol><p>此处通过 <code>makeListener</code> 解析出监听器：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token comment">/** * Register an event listener with the dispatcher. * * @param  \Closure|string  $listener * @param  bool  $wildcard * @return \Closure */</span><span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">makeListener</span><span class="token punctuation">(</span><span class="token variable">$listener</span><span class="token punctuation">,</span> <span class="token variable">$wildcard</span> <span class="token operator">=</span> <span class="token constant boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">is_string</span><span class="token punctuation">(</span><span class="token variable">$listener</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token variable">$this</span><span class="token operator">-></span><span class="token function">createClassListener</span><span class="token punctuation">(</span><span class="token variable">$listener</span><span class="token punctuation">,</span> <span class="token variable">$wildcard</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token variable">$event</span><span class="token punctuation">,</span> <span class="token variable">$payload</span><span class="token punctuation">)</span> <span class="token keyword">use</span> <span class="token punctuation">(</span><span class="token variable">$listener</span><span class="token punctuation">,</span> <span class="token variable">$wildcard</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$wildcard</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token variable">$listener</span><span class="token punctuation">(</span><span class="token variable">$event</span><span class="token punctuation">,</span> <span class="token variable">$payload</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>      <span class="token keyword">return</span> <span class="token variable">$listener</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token function">array_values</span><span class="token punctuation">(</span><span class="token variable">$payload</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果 <code>$listener</code> 是字符串 ：那么会通过<code>createClassListener</code> 来 将监听方法解析为闭包</p><p>如果 <code>$listener</code> 是闭包，那么也会封装为统一的闭包</p><p><code>createClassListener</code> :</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token comment">/** * Create a class based listener using the IoC container. * * @param  string  $listener * @param  bool  $wildcard * @return \Closure */</span><span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">createClassListener</span><span class="token punctuation">(</span><span class="token variable">$listener</span><span class="token punctuation">,</span> <span class="token variable">$wildcard</span> <span class="token operator">=</span> <span class="token constant boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token variable">$event</span><span class="token punctuation">,</span> <span class="token variable">$payload</span><span class="token punctuation">)</span> <span class="token keyword">use</span> <span class="token punctuation">(</span><span class="token variable">$listener</span><span class="token punctuation">,</span> <span class="token variable">$wildcard</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$wildcard</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token function">call_user_func</span><span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-></span><span class="token function">createClassCallable</span><span class="token punctuation">(</span><span class="token variable">$listener</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token variable">$event</span><span class="token punctuation">,</span> <span class="token variable">$payload</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token function">call_user_func_array</span><span class="token punctuation">(</span>            <span class="token variable">$this</span><span class="token operator">-></span><span class="token function">createClassCallable</span><span class="token punctuation">(</span><span class="token variable">$listener</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token variable">$payload</span>        <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过 <code>createClassCallable</code> 从服务容器中解析出 对应的类方法:</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token comment">/** * Create the class based event callable. * * @param  string  $listener * @return callable */</span><span class="token keyword">protected</span> <span class="token keyword">function</span> <span class="token function">createClassCallable</span><span class="token punctuation">(</span><span class="token variable">$listener</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">list</span><span class="token punctuation">(</span><span class="token variable">$class</span><span class="token punctuation">,</span> <span class="token variable">$method</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token variable">$this</span><span class="token operator">-></span><span class="token function">parseClassCallable</span><span class="token punctuation">(</span><span class="token variable">$listener</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/**队列代码  忽略    if ($this->handlerShouldBeQueued($class)) &#123;        return $this->createQueuedHandlerCallable($class, $method);    &#125;**/</span>    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token variable">$this</span><span class="token operator">-></span><span class="token property">container</span><span class="token operator">-></span><span class="token function">make</span><span class="token punctuation">(</span><span class="token variable">$class</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token variable">$method</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">protected</span> <span class="token keyword">function</span> <span class="token function">parseClassCallable</span><span class="token punctuation">(</span><span class="token variable">$listener</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token class-name static-context">Str</span><span class="token operator">::</span><span class="token function">parseCallback</span><span class="token punctuation">(</span><span class="token variable">$listener</span><span class="token punctuation">,</span> <span class="token string single-quoted-string">'handle'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">function</span> <span class="token function">parseCallback</span><span class="token punctuation">(</span><span class="token variable">$callback</span><span class="token punctuation">,</span> <span class="token variable">$default</span> <span class="token operator">=</span> <span class="token constant">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token keyword static-context">static</span><span class="token operator">::</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token variable">$callback</span><span class="token punctuation">,</span> <span class="token string single-quoted-string">'@'</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">explode</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'@'</span><span class="token punctuation">,</span> <span class="token variable">$callback</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token variable">$callback</span><span class="token punctuation">,</span> <span class="token variable">$default</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>subscribe()</code> 方法的实现依赖于 <code>listen()</code>方法</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token variable">$subscriber</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token variable">$subscriber</span> <span class="token operator">=</span> <span class="token variable">$this</span><span class="token operator">-></span><span class="token function">resolveSubscriber</span><span class="token punctuation">(</span><span class="token variable">$subscriber</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$subscriber</span><span class="token operator">-></span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token variable">$this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">protected</span> <span class="token keyword">function</span> <span class="token function">resolveSubscriber</span><span class="token punctuation">(</span><span class="token variable">$subscriber</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">is_string</span><span class="token punctuation">(</span><span class="token variable">$subscriber</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token variable">$this</span><span class="token operator">-></span><span class="token property">container</span><span class="token operator">-></span><span class="token function">make</span><span class="token punctuation">(</span><span class="token variable">$subscriber</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token variable">$subscriber</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/**自定义的订阅者 subscribe() 方法 示例*/</span><span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token variable">$events</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">//接口响应事件</span>  <span class="token variable">$events</span><span class="token operator">-></span><span class="token function">listen</span><span class="token punctuation">(</span>    <span class="token class-name static-context">RequestHandled</span><span class="token operator">::</span><span class="token keyword">class</span><span class="token punctuation">,</span>    <span class="token string single-quoted-string">'App\Listeners\AlertEventSubscriber@onApiResponse'</span>  <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//提交服务单事件</span>  <span class="token variable">$events</span><span class="token operator">-></span><span class="token function">listen</span><span class="token punctuation">(</span>    <span class="token class-name static-context">CommitWorkOrder</span><span class="token operator">::</span><span class="token keyword">class</span><span class="token punctuation">,</span>    <span class="token string single-quoted-string">'App\Listeners\AlertEventSubscriber@onCommitInsurance'</span>  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="四-事件触发"><a href="#四-事件触发" class="headerlink" title="四. 事件触发"></a>四. 事件触发</h3><p><code>event()</code> 方法实现：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token comment">/*** Dispatch an event and call the listeners.** @param  string|object  $event* @param  mixed  $payload* @param  bool  $halt* @return array|null*/</span><span class="token keyword">function</span> <span class="token function">event</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token variable">$args</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token function">app</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'events'</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token variable">$args</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>dispatch()</code> 方法：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token comment">/*** Fire an event and call the listeners.** @param  string|object  $event* @param  mixed  $payload* @param  bool  $halt* @return array|null*/</span><span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token variable">$event</span><span class="token punctuation">,</span> <span class="token variable">$payload</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token variable">$halt</span> <span class="token operator">=</span> <span class="token constant boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//当给定的“事件”实际上是一个对象时，我们将假定它是一个事件</span>    <span class="token comment">//对象，并使用类作为事件名称，并使用该事件本身作为处理程序的有效负载，这使基于对象的事件非常简单</span>    <span class="token keyword">list</span><span class="token punctuation">(</span><span class="token variable">$event</span><span class="token punctuation">,</span> <span class="token variable">$payload</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token variable">$this</span><span class="token operator">-></span><span class="token function">parseEventAndPayload</span><span class="token punctuation">(</span>        <span class="token variable">$event</span><span class="token punctuation">,</span> <span class="token variable">$payload</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-></span><span class="token function">shouldBroadcast</span><span class="token punctuation">(</span><span class="token variable">$payload</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token variable">$this</span><span class="token operator">-></span><span class="token function">broadcastEvent</span><span class="token punctuation">(</span><span class="token variable">$payload</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token variable">$responses</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-></span><span class="token function">getListeners</span><span class="token punctuation">(</span><span class="token variable">$event</span><span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token variable">$listener</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token variable">$response</span> <span class="token operator">=</span> <span class="token variable">$listener</span><span class="token punctuation">(</span><span class="token variable">$event</span><span class="token punctuation">,</span> <span class="token variable">$payload</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//如果侦听器返回了响应，并且启用了事件暂停功能，</span>        <span class="token comment">//我们将仅返回此响应，而不会调用事件的其余部分</span>        <span class="token comment">//。否则，我们会将响应添加到响应列表中。</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$halt</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span> <span class="token function">is_null</span><span class="token punctuation">(</span><span class="token variable">$response</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token variable">$response</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//如果侦听器返回了布尔值false，我们将停止将该事件传播到链中的其他侦听器，否则我们将继续</span>        <span class="token comment">//遍历侦听器并触发序列中的每个侦听器。</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$response</span> <span class="token operator">===</span> <span class="token constant boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token variable">$responses</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$response</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token variable">$halt</span> <span class="token operator">?</span> <span class="token argument-name">null</span> <span class="token punctuation">:</span> <span class="token variable">$responses</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里通过 <code>parseEventAndPayload()</code> 解析出 事件和参数，如果是对象事件，将对象的类名作为事件名，事件本身作为参数</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token keyword">protected</span> <span class="token keyword">function</span> <span class="token function">parseEventAndPayload</span><span class="token punctuation">(</span><span class="token variable">$event</span><span class="token punctuation">,</span> <span class="token variable">$payload</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">is_object</span><span class="token punctuation">(</span><span class="token variable">$event</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">list</span><span class="token punctuation">(</span><span class="token variable">$payload</span><span class="token punctuation">,</span> <span class="token variable">$event</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token variable">$event</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token function">get_class</span><span class="token punctuation">(</span><span class="token variable">$event</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token variable">$event</span><span class="token punctuation">,</span> <span class="token class-name static-context">Arr</span><span class="token operator">::</span><span class="token function">wrap</span><span class="token punctuation">(</span><span class="token variable">$payload</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>getListeners()</code> 方法：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">getListeners</span><span class="token punctuation">(</span><span class="token variable">$eventName</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token variable">$listeners</span> <span class="token operator">=</span> <span class="token variable">$this</span><span class="token operator">-></span><span class="token property">listeners</span><span class="token punctuation">[</span><span class="token variable">$eventName</span><span class="token punctuation">]</span> <span class="token operator">??</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token variable">$listeners</span> <span class="token operator">=</span> <span class="token function">array_merge</span><span class="token punctuation">(</span>        <span class="token variable">$listeners</span><span class="token punctuation">,</span> <span class="token variable">$this</span><span class="token operator">-></span><span class="token function">getWildcardListeners</span><span class="token punctuation">(</span><span class="token variable">$eventName</span><span class="token punctuation">)</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">class_exists</span><span class="token punctuation">(</span><span class="token variable">$eventName</span><span class="token punctuation">,</span> <span class="token constant boolean">false</span><span class="token punctuation">)</span>    <span class="token operator">?</span> <span class="token variable">$this</span><span class="token operator">-></span><span class="token function">addInterfaceListeners</span><span class="token punctuation">(</span><span class="token variable">$eventName</span><span class="token punctuation">,</span> <span class="token variable">$listeners</span><span class="token punctuation">)</span>    <span class="token punctuation">:</span> <span class="token variable">$listeners</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">protected</span> <span class="token keyword">function</span> <span class="token function">getWildcardListeners</span><span class="token punctuation">(</span><span class="token variable">$eventName</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token variable">$wildcards</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-></span><span class="token property">wildcards</span> <span class="token keyword">as</span> <span class="token variable">$key</span> <span class="token operator">=></span> <span class="token variable">$listeners</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name static-context">Str</span><span class="token operator">::</span><span class="token function">is</span><span class="token punctuation">(</span><span class="token variable">$key</span><span class="token punctuation">,</span> <span class="token variable">$eventName</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token variable">$wildcards</span> <span class="token operator">=</span> <span class="token function">array_merge</span><span class="token punctuation">(</span><span class="token variable">$wildcards</span><span class="token punctuation">,</span> <span class="token variable">$listeners</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token variable">$wildcards</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/*** 基于接口的事件冒泡* Add the listeners for the event's interfaces to the given array.** @param  string  $eventName* @param  array  $listeners* @return array*/</span><span class="token keyword">protected</span> <span class="token keyword">function</span> <span class="token function">addInterfaceListeners</span><span class="token punctuation">(</span><span class="token variable">$eventName</span><span class="token punctuation">,</span> <span class="token keyword type-hint">array</span> <span class="token variable">$listeners</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token function">class_implements</span><span class="token punctuation">(</span><span class="token variable">$eventName</span><span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token variable">$interface</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">isset</span><span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-></span><span class="token property">listeners</span><span class="token punctuation">[</span><span class="token variable">$interface</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-></span><span class="token property">listeners</span><span class="token punctuation">[</span><span class="token variable">$interface</span><span class="token punctuation">]</span> <span class="token keyword">as</span> <span class="token variable">$names</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token variable">$listeners</span> <span class="token operator">=</span> <span class="token function">array_merge</span><span class="token punctuation">(</span><span class="token variable">$listeners</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword type-casting">array</span><span class="token punctuation">)</span> <span class="token variable">$names</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token variable">$listeners</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Laravel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Laravel </tag>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
